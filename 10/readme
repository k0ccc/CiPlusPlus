Цель: Создать класс, который хранит указатель на данные, находящиеся вне этого класса. Понять разницу между владением и наблюдением.
Объяснение:

    Класс может содержать член-указатель (int* ptr_member;).
    В этой задаче мы сделаем так, чтобы этот указатель указывал на переменную, которая была создана снаружи объекта нашего класса (например, в main).
    Важно: В этом случае наш класс не владеет памятью, на которую указывает ptr_member. Он лишь "наблюдает" за ней или использует ее. Это значит, что наш класс не должен пытаться освободить эту память (delete) в своем деструкторе! Ответственность за время жизни внешней переменной лежит на том коде, который ее создал.
    Риск: Если внешняя переменная будет уничтожена раньше, чем объект нашего класса, который на нее указывает, то указатель ptr_member станет висячим (dangling pointer), и попытка его разыменовать приведет к неопределенному поведению. (Это одна из причин, почему для владения динамической памятью используются умные указатели вроде unique_ptr).

Задание:

    Создайте класс IntObserver ("Наблюдатель за Int").
    В private: секции объявите член-указатель int* observed_ptr_ = nullptr; (инициализируем нулем для безопасности).
    В public: секции создайте конструктор explicit IntObserver(int* ptr), который принимает указатель на int и сохраняет его в observed_ptr_. Используйте список инициализации.
    Добавьте public метод void printObservedValue() const, который проверяет, не является ли observed_ptr_ нулевым (nullptr), и если нет, то разыменовывает его (*observed_ptr_) и печатает значение. Если указатель нулевой, выведите сообщение об этом.
    В main создайте переменную int externalValue = 10;.
    Создайте объект IntObserver obs1(&externalValue);.
    Вызовите obs1.printObservedValue().
    Измените значение externalValue (например, externalValue = 20;).
    Снова вызовите obs1.printObservedValue() и убедитесь, что наблюдатель видит новое значение.
    Создайте еще один объект IntObserver obs2(nullptr); и вызовите его метод printObservedValue().